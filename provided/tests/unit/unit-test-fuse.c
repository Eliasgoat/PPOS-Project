#include <check.h>
#include "test.h"
#include "mount.h"
#include "u6fs_fuse.h"
#include "inode.h"

#define SIMPLE_DISK DATA_DIR "/simple.uv6"
#define FIRST_DISK  DATA_DIR "/first.uv6"
#define AIW_DISK  DATA_DIR "/aiw.uv6"

START_TEST(fs_getattr_null_param) {
	start_test_print;

	fuse_set_fs(NON_NULL);

	ck_assert_invalid_arg(fs_getattr(NULL, NON_NULL));
	ck_assert_invalid_arg(fs_getattr(NON_NULL, NULL));
	ck_assert_invalid_arg(fs_getattr(NULL, NULL));

	fuse_set_fs(NULL);

	end_test_print;
}
END_TEST

START_TEST(fs_getattr_no_fs) {
	start_test_print;

	fuse_set_fs(NULL);
	ck_assert_invalid_arg(fs_getattr(NON_NULL, NON_NULL));

	end_test_print;
}
END_TEST

START_TEST(fs_getattr_invalid_file) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(SIMPLE_DISK, &fs));
	fuse_set_fs(&fs);

	ck_assert_err(fs_getattr("/tmp/hello.txt", NON_NULL), ERR_NO_SUCH_FILE);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

START_TEST(fs_getattr_valid) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(SIMPLE_DISK, &fs));
	fuse_set_fs(&fs);

	struct stat stats = {0};
	ck_assert_err_none(fs_getattr("/tmp", &stats));

	ck_assert_int_eq(stats.st_dev, 0);
	ck_assert_int_eq(stats.st_ino, 2);
	ck_assert_int_eq(stats.st_mode, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH | S_IFDIR);
	ck_assert_int_eq(stats.st_nlink, 0);
	ck_assert_int_eq(stats.st_uid, 0);
	ck_assert_int_eq(stats.st_gid, 0);
	ck_assert_int_eq(stats.st_rdev, 0);
	ck_assert_int_eq(stats.st_size, 16);
	ck_assert_int_eq(stats.st_blksize, 512);
	ck_assert_int_eq(stats.st_blocks, 1);

	ck_assert_err_none(fs_getattr("/tmp/coucou.txt", &stats));

	ck_assert_int_eq(stats.st_dev, 0);
	ck_assert_int_eq(stats.st_ino, 3);
	ck_assert_int_eq(stats.st_mode, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH | S_IFREG);
	ck_assert_int_eq(stats.st_nlink, 0);
	ck_assert_int_eq(stats.st_uid, 0);
	ck_assert_int_eq(stats.st_gid, 0);
	ck_assert_int_eq(stats.st_rdev, 0);
	ck_assert_int_eq(stats.st_size, 18);
	ck_assert_int_eq(stats.st_blksize, 512);
	ck_assert_int_eq(stats.st_blocks, 1);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

START_TEST(fs_readdir_null_param) {
	start_test_print;

	fuse_set_fs(NON_NULL);

	ck_assert_invalid_arg(fs_readdir(NULL, NON_NULL, NON_NULL, 0, NON_NULL));
	ck_assert_invalid_arg(fs_readdir(NON_NULL, NULL, NON_NULL, 0, NON_NULL));
	ck_assert_invalid_arg(fs_readdir(NON_NULL, NON_NULL, NULL, 0, NON_NULL));
	ck_assert_invalid_arg(fs_readdir(NON_NULL, NON_NULL, NON_NULL, 0, NULL));

	fuse_set_fs(NULL);

	end_test_print;
}
END_TEST

START_TEST(fs_readdir_no_fs) {
	start_test_print;

	fuse_set_fs(NULL);
	ck_assert_invalid_arg(fs_readdir(NON_NULL, NON_NULL, NON_NULL, 0, NON_NULL));

	end_test_print;
}
END_TEST

START_TEST(fs_readdir_invalid_file) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(SIMPLE_DISK, &fs));
	fuse_set_fs(&fs);

	ck_assert_err(fs_readdir("/usr", NON_NULL, NON_NULL, 0, NON_NULL), ERR_NO_SUCH_FILE);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

int no_mem_filler(void *buf, const char *path, const struct stat *stats, off_t off) {
	return 1;
}

START_TEST(fs_readdir_no_mem) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(AIW_DISK, &fs));
	fuse_set_fs(&fs);

	ck_assert_err(fs_readdir("/", NON_NULL, no_mem_filler, 0, NON_NULL), ERR_NOMEM);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

struct TestFillerEntry {
	char *path;
	struct stat stats;
	char visited;
};
struct TestFillerBuf {
	struct unix_filesystem *fs;
	struct TestFillerEntry *entries;
	const char *scanned_dir;
	uint32_t entries_count;
};

int test_filler(void *b, const char *path, const struct stat *stats, off_t off) {
	struct TestFillerBuf *buf = b;

	for (int i = 0; i < buf->entries_count; ++i) {
		struct TestFillerEntry *entry = buf->entries + i;

		if (!strcmp(path, entry->path)) {
			ck_assert_msg(!entry->visited, "Entry %s already visited", path);

			entry->visited = 1;

			ck_assert_msg(stats == NULL
						  || !memcmp(stats, &entry->stats, sizeof(struct stat)),
						  "Invalid stat struct for entry %s while reading %s", path, buf->scanned_dir);

			return 0;
		}
	}

	ck_abort_msg("Try to add incorrect path %s while reading %s", path, buf->scanned_dir);

}

#define FILL_ENTRY(entry, name, dir) \
    do {                                \
        entry.path = name;              \
        ck_assert_err_none(fs_getattr(dir "/" name, &entry.stats));\
    } while(0)

START_TEST(fs_readdir_valid) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(FIRST_DISK, &fs));
	fuse_set_fs(&fs);

	struct TestFillerEntry entries[7] = {0};
	entries[0].path=".";
	entries[1].path="..";
	FILL_ENTRY(entries[2], "child_test.go", "/hello/net/http/cgi");
	FILL_ENTRY(entries[3], "testdata", "/hello/net/http/cgi");
	FILL_ENTRY(entries[4], "plan9_test.go", "/hello/net/http/cgi");
	FILL_ENTRY(entries[5], "posix_test.go", "/hello/net/http/cgi");

	struct TestFillerBuf buf = {
			&fs,
			entries,
			"/hello/net/http/cgi",
			6
	};

	ck_assert_err_none(fs_readdir("/hello/net/http/cgi", &buf, test_filler, 0, NON_NULL));

	for (int i = 0; i < buf.entries_count; ++i) {
		if (!buf.entries[i].visited) {
			ck_abort_msg("Missed entry %s while visiting /hello/net/http/cgi", buf.entries[i].path);
		}
	}

	fuse_set_fs(NULL);
    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

START_TEST(fs_read_null_param) {
	start_test_print;

	ck_assert_invalid_arg(fs_read(NULL, NON_NULL, 0, 0, NON_NULL));
	ck_assert_invalid_arg(fs_read(NON_NULL, NULL, 0, 0, NON_NULL));
	ck_assert_invalid_arg(fs_read(NON_NULL, NON_NULL, 0, 0, NULL));

	end_test_print;
}
END_TEST

START_TEST(fs_read_no_fs) {
	start_test_print;

	ck_assert_invalid_arg(fs_read(NON_NULL, NON_NULL, 0, 0, NON_NULL));

	end_test_print;
}
END_TEST

START_TEST(fs_read_invalid_file) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(SIMPLE_DISK, &fs));
	fuse_set_fs(&fs);

	ck_assert_err(fs_read("/tmp/hello.txt", NON_NULL, 1, 0, NON_NULL), ERR_NO_SUCH_FILE);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

#define READ_SIZE 1024
START_TEST(fs_read_valid) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(SIMPLE_DISK, &fs));
	fuse_set_fs(&fs);

	char buf[READ_SIZE+1] = {0};  // ensures null termination
	ck_assert_err(fs_read("/tmp/coucou.txt", buf, READ_SIZE, 0, NON_NULL), 18);
	ck_assert_str_eq(buf, "Coucou le monde !\n");

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

START_TEST(fs_read_valid_offset) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(FIRST_DISK, &fs));
	fuse_set_fs(&fs);

	char buf[READ_SIZE+1] = {0};  // ensures null termination
    // Hexdump of the sectors, because it's easier to generate
    char expected[] = {
        0x20, 0x3a, 0x3d, 0x20, 0x4e, 0x65, 0x77, 0x57, 0x72, 0x69, 0x74, 0x65,
        0x72, 0x28, 0x62, 0x75, 0x66, 0x69, 0x6f, 0x2e, 0x4e, 0x65, 0x77, 0x57,
        0x72, 0x69, 0x74, 0x65, 0x72, 0x28, 0x26, 0x62, 0x75, 0x66, 0x29, 0x29,
        0x0a, 0x09, 0x64, 0x20, 0x3a, 0x3d, 0x20, 0x77, 0x2e, 0x44, 0x6f, 0x74,
        0x57, 0x72, 0x69, 0x74, 0x65, 0x72, 0x28, 0x29, 0x0a, 0x09, 0x6e, 0x2c,
        0x20, 0x65, 0x72, 0x72, 0x20, 0x3a, 0x3d, 0x20, 0x64, 0x2e, 0x57, 0x72,
        0x69, 0x74, 0x65, 0x28, 0x5b, 0x5d, 0x62, 0x79, 0x74, 0x65, 0x28, 0x22,
        0x61, 0x62, 0x63, 0x5c, 0x6e, 0x2e, 0x64, 0x65, 0x66, 0x5c, 0x6e, 0x2e,
        0x2e, 0x67, 0x68, 0x69, 0x5c, 0x6e, 0x2e, 0x6a, 0x6b, 0x6c, 0x5c, 0x6e,
        0x2e, 0x22, 0x29, 0x29, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x6e, 0x20, 0x21,
        0x3d, 0x20, 0x32, 0x31, 0x20, 0x7c, 0x7c, 0x20, 0x65, 0x72, 0x72, 0x20,
        0x21, 0x3d, 0x20, 0x6e, 0x69, 0x6c, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74,
        0x2e, 0x46, 0x61, 0x74, 0x61, 0x6c, 0x66, 0x28, 0x22, 0x57, 0x72, 0x69,
        0x74, 0x65, 0x3a, 0x20, 0x25, 0x64, 0x2c, 0x20, 0x25, 0x73, 0x22, 0x2c,
        0x20, 0x6e, 0x2c, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0a, 0x09, 0x7d, 0x0a,
        0x09, 0x64, 0x2e, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x28, 0x29, 0x0a, 0x09,
        0x77, 0x61, 0x6e, 0x74, 0x20, 0x3a, 0x3d, 0x20, 0x22, 0x61, 0x62, 0x63,
        0x5c, 0x72, 0x5c, 0x6e, 0x2e, 0x2e, 0x64, 0x65, 0x66, 0x5c, 0x72, 0x5c,
        0x6e, 0x2e, 0x2e, 0x2e, 0x67, 0x68, 0x69, 0x5c, 0x72, 0x5c, 0x6e, 0x2e,
        0x2e, 0x6a, 0x6b, 0x6c, 0x5c, 0x72, 0x5c, 0x6e, 0x2e, 0x2e, 0x5c, 0x72,
        0x5c, 0x6e, 0x2e, 0x5c, 0x72, 0x5c, 0x6e, 0x22, 0x0a, 0x09, 0x69, 0x66,
        0x20, 0x73, 0x20, 0x3a, 0x3d, 0x20, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74,
        0x72, 0x69, 0x6e, 0x67, 0x28, 0x29, 0x3b, 0x20, 0x73, 0x20, 0x21, 0x3d,
        0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e,
        0x46, 0x61, 0x74, 0x61, 0x6c, 0x66, 0x28, 0x22, 0x77, 0x72, 0x6f, 0x74,
        0x65, 0x20, 0x25, 0x71, 0x22, 0x2c, 0x20, 0x73, 0x29, 0x0a, 0x09, 0x7d,
        0x0a, 0x7d, 0x0a, 0x00
    };


	ck_assert_err(fs_read("/hello/net/textproto/writer_test.go", buf, READ_SIZE, SECTOR_SIZE, NON_NULL), 315);
	ck_assert_str_eq(buf, expected);

	fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
	end_test_print;
}
END_TEST

START_TEST(fs_read_valid_offset_with_fixed_size) {
    start_test_print;

    struct unix_filesystem fs = {0};
    ck_assert_err_none(mountv6(FIRST_DISK, &fs));
    fuse_set_fs(&fs);

    // Hexdump of the sectors, because it's easier to generate
    char buf[2 * SECTOR_SIZE + 1] = {0};
    char expected[] = {
        0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x66, 0x28, 0x22, 0x64, 0x69, 0x64,
        0x6e, 0x27, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x20, 0x75, 0x73,
        0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x09, 0x7d, 0x0a,
        0x7d, 0x0a, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x20, 0x63, 0x6f, 0x6d, 0x70,
        0x61, 0x72, 0x65, 0x28, 0x74, 0x20, 0x2a, 0x74, 0x65, 0x73, 0x74, 0x69,
        0x6e, 0x67, 0x2e, 0x54, 0x2c, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2c, 0x20,
        0x67, 0x6f, 0x74, 0x20, 0x2a, 0x55, 0x73, 0x65, 0x72, 0x29, 0x20, 0x7b,
        0x0a, 0x09, 0x69, 0x66, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x55, 0x69,
        0x64, 0x20, 0x21, 0x3d, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x55, 0x69, 0x64,
        0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72,
        0x66, 0x28, 0x22, 0x67, 0x6f, 0x74, 0x20, 0x55, 0x69, 0x64, 0x3d, 0x25,
        0x71, 0x3b, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x25, 0x71, 0x22, 0x2c,
        0x20, 0x67, 0x6f, 0x74, 0x2e, 0x55, 0x69, 0x64, 0x2c, 0x20, 0x77, 0x61,
        0x6e, 0x74, 0x2e, 0x55, 0x69, 0x64, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09,
        0x69, 0x66, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x55, 0x73, 0x65, 0x72,
        0x6e, 0x61, 0x6d, 0x65, 0x20, 0x21, 0x3d, 0x20, 0x67, 0x6f, 0x74, 0x2e,
        0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x7b, 0x0a, 0x09,
        0x09, 0x74, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x66, 0x28, 0x22, 0x67,
        0x6f, 0x74, 0x20, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x3d,
        0x25, 0x71, 0x3b, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x25, 0x71, 0x22,
        0x2c, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x2c, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69,
        0x66, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x20,
        0x21, 0x3d, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x20,
        0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x66,
        0x28, 0x22, 0x67, 0x6f, 0x74, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x3d, 0x25,
        0x71, 0x3b, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x25, 0x71, 0x22, 0x2c,
        0x20, 0x67, 0x6f, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x77,
        0x61, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x09, 0x7d,
        0x0a, 0x09, 0x2f, 0x2f, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x72,
        0x61, 0x69, 0x6e, 0x6d, 0x61, 0x6e, 0x29, 0x3a, 0x20, 0x66, 0x69, 0x78,
        0x20, 0x69, 0x74, 0x20, 0x6f, 0x6e, 0x63, 0x65, 0x20, 0x77, 0x65, 0x20,
        0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x2e, 0x0a, 0x09, 0x69,
        0x66, 0x20, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x47, 0x4f,
        0x4f, 0x53, 0x20, 0x3d, 0x3d, 0x20, 0x22, 0x77, 0x69, 0x6e, 0x64, 0x6f,
        0x77, 0x73, 0x22, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e, 0x53, 0x6b,
        0x69, 0x70, 0x28, 0x22, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x69, 0x6e, 0x67,
        0x20, 0x47, 0x69, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x48, 0x6f, 0x6d,
        0x65, 0x44, 0x69, 0x72, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x72, 0x69,
        0x73, 0x6f, 0x6e, 0x73, 0x22, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69,
        0x66, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x47, 0x69, 0x64, 0x20, 0x21,
        0x3d, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x47, 0x69, 0x64, 0x20, 0x7b, 0x0a,
        0x09, 0x09, 0x74, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x66, 0x28, 0x22,
        0x67, 0x6f, 0x74, 0x20, 0x47, 0x69, 0x64, 0x3d, 0x25, 0x71, 0x3b, 0x20,
        0x77, 0x61, 0x6e, 0x74, 0x20, 0x25, 0x71, 0x22, 0x2c, 0x20, 0x67, 0x6f,
        0x74, 0x2e, 0x47, 0x69, 0x64, 0x2c, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x2e,
        0x47, 0x69, 0x64, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x69, 0x66, 0x20,
        0x77, 0x61, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x6d, 0x65, 0x44, 0x69, 0x72,
        0x20, 0x21, 0x3d, 0x20, 0x67, 0x6f, 0x74, 0x2e, 0x48, 0x6f, 0x6d, 0x65,
        0x44, 0x69, 0x72, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e, 0x45, 0x72,
        0x72, 0x6f, 0x72, 0x66, 0x28, 0x22, 0x67, 0x6f, 0x74, 0x20, 0x48, 0x6f,
        0x6d, 0x65, 0x44, 0x69, 0x72, 0x3d, 0x25, 0x71, 0x3b, 0x20, 0x77, 0x61,
        0x6e, 0x74, 0x20, 0x25, 0x71, 0x22, 0x2c, 0x20, 0x67, 0x6f, 0x74, 0x2e,
        0x48, 0x6f, 0x6d, 0x65, 0x44, 0x69, 0x72, 0x2c, 0x20, 0x77, 0x61, 0x6e,
        0x74, 0x2e, 0x48, 0x6f, 0x6d, 0x65, 0x44, 0x69, 0x72, 0x29, 0x0a, 0x09,
        0x7d, 0x0a, 0x7d, 0x0a, 0x0a, 0x66, 0x75, 0x6e, 0x63, 0x20, 0x54, 0x65,
        0x73, 0x74, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x28, 0x74, 0x20, 0x2a,
        0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x54, 0x29, 0x20, 0x7b,
        0x0a, 0x09, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x28, 0x74, 0x29, 0x0a, 0x0a,
        0x09, 0x69, 0x66, 0x20, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e,
        0x47, 0x4f, 0x4f, 0x53, 0x20, 0x3d, 0x3d, 0x20, 0x22, 0x70, 0x6c, 0x61,
        0x6e, 0x39, 0x22, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x2e, 0x53, 0x6b,
        0x69, 0x70, 0x66, 0x28, 0x22, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x20,
        0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x25, 0x71, 0x22, 0x2c, 0x20,
        0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x47, 0x4f, 0x4f, 0x53,
        0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x0a, 0x09, 0x77, 0x61, 0x6e, 0x74, 0x2c,
        0x20, 0x65, 0x72, 0x72, 0x20, 0x3a, 0x3d, 0x20, 0x43, 0x75, 0x72, 0x72,
        0x65, 0x6e, 0x74, 0x28, 0x29, 0x0a, 0x09, 0x69, 0x66, 0x20, 0x65, 0x72,
        0x72, 0x20, 0x21, 0x3d, 0x20, 0x6e, 0x69, 0x6c, 0x20, 0x7b, 0x0a, 0x09,
        0x09, 0x74, 0x2e, 0x46, 0x61, 0x74, 0x61, 0x6c, 0x66, 0x28, 0x22, 0x43,
        0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x25, 0x76, 0x22, 0x2c,
        0x20, 0x65, 0x72, 0x72, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x67, 0x6f,
        0x74, 0x2c, 0x20, 0x65, 0x72, 0x72, 0x20, 0x3a, 0x3d, 0x20, 0x4c, 0x6f,
        0x6f, 0x6b, 0x75, 0x70, 0x28, 0x77, 0x61, 0x6e, 0x74, 0x2e, 0x55, 0x73,
        0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x09, 0x69, 0x66, 0x20,
        0x65, 0x72, 0x72, 0x20, 0x21, 0x3d, 0x20, 0x6e, 0x69, 0x6c, 0x20, 0x7b,
        0x0a, 0x09, 0x09, 0x74, 0x2e, 0x46, 0x61, 0x74, 0x61, 0x6c, 0x66, 0x28,
        0x22, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x3a, 0x20, 0x25, 0x76, 0x22,
        0x2c, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x63,
        0x6f, 0x6d, 0x70, 0x61, 0x72, 0x65, 0x28, 0x74, 0x2c, 0x20, 0x77, 0x61,
        0x6e, 0x74, 0x2c, 0x20, 0x67, 0x6f, 0x74, 0x29, 0x0a, 0x7d, 0x0a, 0x0a,
        0x66, 0x75, 0x6e, 0x63, 0x20, 0x54, 0x65, 0x73, 0x74, 0x4c, 0x6f, 0x6f,
        0x6b, 0x75, 0x70, 0x49, 0x64, 0x28, 0x74, 0x20, 0x2a, 0x74, 0x65, 0x73,
        0x74, 0x69, 0x6e, 0x67, 0x00
    };

    ck_assert_err(fs_read("/hello/os/user/user_test.go", buf, 2 * SECTOR_SIZE, SECTOR_SIZE, NON_NULL), 2 * SECTOR_SIZE);
    buf[2 * SECTOR_SIZE] = 0;
    ck_assert_str_eq(buf, expected);

    fuse_set_fs(NULL);

    ck_assert_err_none(umountv6(&fs));
    end_test_print;
}
END_TEST

START_TEST(fs_read_valid_too_big) {
	start_test_print;

	struct unix_filesystem fs = {0};
	ck_assert_err_none(mountv6(FIRST_DISK, &fs));
	fuse_set_fs(&fs);

	char buf[READ_SIZE+1];
	const char *expected = "// Copyright 2011 The Go Authors. All rights reserved.\n"
                           "// Use of this source code is governed by a BSD-style\n"
                           "// license that can be found in the LICENSE file.\n"
                           "\n"
                           "// Tests for CGI (the child process perspective)\n"
                           "\n"
                           "package cgi\n"
                           "\n"
                           "import (\n"
                           "\t\"testing\"\n"
                           ")\n"
                           "\n"
                           "func TestRequest(t *testing.T) {\n"
                           "\tenv := map[string]string{\n"
                           "\t\t\"SERVER_PROTOCOL\": \"HTTP/1.1\",\n"
                           "\t\t\"REQUEST_METHOD\":  \"GET\",\n"
                           "\t\t\"HTTP_HOST\":       \"example.com\",\n"
                           "\t\t\"HTTP_REFERER\":    \"elsewhere\",\n"
                           "\t\t\"HTTP_USER_AGENT\": \"goclient\",\n"
                           "\t\t\"HTTP_FOO_BAR\":    \"baz\",\n"
                           "\t\t\"REQUEST_URI\":     \"/path?a=b\",\n"
                           "\t\t\"CONTENT_LENGTH\":  \"123\",\n"
                           "\t\t\"CONTENT_TYPE\":    \"text/xml\",\n"
                           "\t\t\"REMOTE_ADDR\":     \"5.6.7.8\",\n"
                           "\t\t\"REMOTE_PORT\":     \"54321\",\n"
                           "\t}\n"
                           "\treq, err := RequestFromMap(env)\n"
                           "\tif err != nil {\n"
                           "\t\tt.Fatalf(\"RequestFromMap: %v\", err)\n"
                           "\t}\n"
                           "\tif g, e := req.UserAgent(), \"goclient\"; e != g {\n"
                           "\t\tt.Errorf(\"expected UserAgent %q; got %q\", e, g)\n"
                           "\t}\n"
                           "\tif g, e := req.Method, \"GET\"; e != g {\n"
                           "\t\tt.Errorf(\"expected Method %q; got %q\", e, g)\n"
                           "\t}\n"
                           "\tif g, e := req.Header.Get(\"Content-Type\"), \"text/xml\"; e != g {\n"
                           "\t\tt.Errorf(\"expec";
	ck_assert_err(fs_read("/hello/net/http/cgi/child_test.go", buf, READ_SIZE, 0, NON_NULL), READ_SIZE);
	buf[READ_SIZE] = 0;
	ck_assert_str_eq(buf, expected);

	fuse_set_fs(NULL);
    ck_assert_err_none(umountv6(&fs));

	end_test_print;
}
END_TEST

Suite *fuse_test_suite() {
	Suite *s = suite_create("Test for fuse functions");

	Add_Test(s,  fs_getattr_null_param);
	Add_Test(s,  fs_getattr_no_fs);
	Add_Test(s,  fs_getattr_invalid_file);
	Add_Test(s,  fs_getattr_valid);

	Add_Test(s,  fs_readdir_null_param);
	Add_Test(s,  fs_readdir_no_fs);
	Add_Test(s,  fs_readdir_invalid_file);
	Add_Test(s,  fs_readdir_no_mem);
	Add_Test(s,  fs_readdir_valid);

	Add_Test(s,  fs_read_null_param);
	Add_Test(s,  fs_read_no_fs);
	Add_Test(s,  fs_read_invalid_file);
	Add_Test(s,  fs_read_valid);
	Add_Test(s,  fs_read_valid_offset);
	Add_Test(s,  fs_read_valid_offset_with_fixed_size);
	Add_Test(s,  fs_read_valid_too_big);

	return s;
}

TEST_SUITE(fuse_test_suite)
